# 一次失败的编译器设计尝试

## 前言

这份代码, 写不下去了. 

在 2021年8月 , 我开始使用 C 编写符合 SysY2021 要求的编译器, 一直到 10月, 写完了前端和表达式的代码生成, 差不多有了 TAC Code Generation 的思路, 然后就... 写不下去了. 

写不下去的原因有很多, 比如说我对后面的算法的不熟悉, 或者是前期的设计失误之类的. 不管怎么样, 作为一个规模上千行的失败的项目, 我觉得应该抓紧机会, 总结一下失败的原因. 

```bash
$ cloc --exclude-dir=.vscode .  
      25 text files.
      25 unique files.                              
       3 files ignored.

github.com/AlDanial/cloc v 1.90  T=0.02 s (1006.4 files/s, 80601.6 lines/s)
-------------------------------------------------------------------------------
Language                     files          blank        comment           code
-------------------------------------------------------------------------------
C                                8            182            279            344
C/C++ Header                     6             83             27            277
Python                           4             61              4            231
yacc                             1             51              5            147
lex                              1             21              1             77
Bourne Shell                     2              9              1             30
Markdown                         1              6              0              6
-------------------------------------------------------------------------------
SUM:                            23            413            317           1112
-------------------------------------------------------------------------------
```

## 目标

## 顶层设计

## 前端

虽然官方给了钦定的 BNF, 但是这并不妨碍我折腾一下...

### 词法

> 代码参考: `frontend/lexer.lex`. 

SysY2021 有一个很怪的要求: 不支持普通的字符串但是要支持一个特殊的 `putf` 函数(相当于弱化版的`printf`)里的字符串. 所以在词法设计上, 我把 `putf` 当作了一个关键字而把字符串当作一种 lexeme. 当然也可以直接把 `putf(".*",` 当作一块, 然后对 `yytext` 做处理提取出 format 字符串的值, 只不过我考虑到后面函数参数的解析方便, 我并没有采取这种方式.

其余的关键字跟符号, 我在 `frontend/parser.y` 的 token 里定义好了, 所以我直接在 `lexer.lex` 里使用对应的枚举值并且 include 一会儿由 parser.y 生成的头文件.  

### 语法

> 代码参考: `frontend/parser.y`

BNF 设计上我比较放飞, 并没有很符合官方钦定的 BNF. 原因嘛有很多, 比如说我不想让 BNF 嵌套这么多层, 或者说我想让 BNF 的结构比较符合我的 AST 的结构. 

这里有一个大坑: 因为我在设计 AST 的时候不想把二元运算拆开为 "Add", "Rel", "Cond" 三种, 所以我把它们打包一起作为一个 "Exp" 了, 这成为了我后面的一个大坑... 

### AST

> 代码参考: `ast.h`

AST 的数据结构在一开始其实并不是现在做的那样用带 type 的匿名枚举, 而是做了一堆结构体模拟继承. 但后来还是发现, 用一堆结构体模拟继承的话, 最后调用的时候也不会方便多少, 而且为了做运行时类型识别, 本来就要加一个 type 字段到基类去. 其实 AST 这种东西, 后面根本就不会再添加新的节点类型了, 那倒不如一开始直接写死有多少节点来得方便, 还能便于 switch 做匹配判断. 

然后我本着方便代码生成器解析代码的思想, 我非常规范地写下了 AST 的定义: 

```c
struct Ast_Node {
    enum Ast_NodeType type;
    union {
        struct {
            string name;
            Ast_List index;
        } lval;


        // --- expr ---
        struct { 
            Ast_ExpAddType op;
            Ast_Node arg1; // Primary Exp
            Ast_Node arg2;
        } exp_add;

        struct {
            Ast_ExpRelType op;
            Ast_Node arg1; // Add Exp
            Ast_Node arg2;
        } exp_rel;

        struct {
            Ast_ExpLogType op;
            Ast_Node arg1; // Rel Exp
            Ast_Node arg2;
        } exp_log;

        struct {
            Ast_Node lval;
        } exp_lval;

        struct {
            string val;
        } exp_num;

        struct {
            string format;
            Ast_List args;
        } exp_putf;

        struct {
            string func;
            Ast_List args;
        } exp_call;


        // --- stmt --- 
        struct {
            Ast_List items;
        } block;

        struct {
            Ast_Node exp;
        } stmt_exp;

        struct {
            Ast_Node cond;
            Ast_Node if_clause;
            Ast_Node else_clause;
        } stmt_if;

        struct {
            Ast_Node cond;
            Ast_Node body;
        } stmt_while;

        struct {
            Ast_Node exp;
        } stmt_return;

        struct {
            Ast_Node lval;
            Ast_Node exp;
        } stmt_assign;


        // --- init ---
        struct {
            Ast_Node exp;
        } init_exp;

        struct {
            Ast_List subs;
        } init_arr;


        // --- other ---
        struct {
            Ast_Node lval;
            Ast_Node init;
        } var_def;

        struct {
            Ast_FuncRetType ret_type;
            string func_name;
            Ast_List params;
            Ast_Node body;
        } func_def;

        struct {
            bool is_const; 
            Ast_List def; 
        } decl;
    };
};
```

这个架构基本上的抄虎书的, 但是去掉了 union 的名字方便访问. 后来发现其实连结构体的名字都不需要, 这个也是代码杂音. 但是因为我的代码生成器大量利用了这个结构体的名字, 所以到后期其实已经无力回天了. 